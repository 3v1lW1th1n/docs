.TH RUNDECK 1 "November 20, 2010" "RunDeck User Manuals" "Version 1.0"
.SH Getting Started
.PP
This chapter will be about getting started with RunDeck.
We will begin by explaining \&... , then move on to \&..., finally
\&... At the end of this chapter you should understand what RunDeck
is, how you should use it and you should be all setup to do so.
.SS RunDeck Basics
.PP
Several fundamental concepts underly and drive the development of
the RunDeck system.
If you are a new user, knowing about them will help you use and
integrate RunDeck into your environment.
.SS Command dispatching
.PP
RunDeck supports a notion called Command dispatching wherein a user
specifies dispatch critera along with an action (called a command)
and this specification is used to perform a distributed execution.
.PP
Internally, a mechanism called the command dispatcher does a lookup
to find node resources meeting specified filtering criteria and
performs the distributed command execution.
The command executes in a data context that contains information
about the Node resource.
.PP
The command dispatcher supports two methods of command execution:
.IP \[bu] 2
Ad hoc commands: Execute any shell command or shell script across a
set of hosts.
.PD 0
.P
.PD

.IP \[bu] 2
Jobs: Encapsulate commands as a named Job and tie them together
into Job workflows.
.PP
RunDeck provides both graphical and command line interfaces to
interact with the command dispatcher.
.SS Resource model
.PP
The command dispatcher works in conjunction with a resource model.
A resource model is a representation of hosts deployed in your
network.
A \f[I]Node\f[] resource is either a physical or virtual instance
of an operating system that is network accessible.
.PP
Nodes have a number of basic properties but these properties can be
extended to include arbitrary named key value pairs.
.PP
You can configure RunDeck to retrieve and store resource model data
from any source, so long as it meets the RunDeck resource model
document requirement.
.SS Authorization
.PP
RunDeck uses an authorization model where users belong to groups
and those groups are associated with abitrarily defined roles.
.PP
Every action executed through the RunDeck command dispatcher must
meet the requirements of an access control policy definition.
.PP
Since RunDeck respects the ACLs definition, you can use role-based
authorization to restrict some users to only a subset of actions.
This provides a Self-Service type interface, where some users can
have access to a limited set of actions to execute.
.SS Project
.PP
All RunDeck activities occur within the context of a single
project.
Each project has its own resource model and Job store.
.PP
Multiple projects can be maintained on the same RunDeck server.
Projects are independent of one another, so you can use them to
organize unrelated systems within a single RunDeck installation.
This can be useful for managing different infrastructures.
.SS Installing RunDeck
.PP
Assuming the system requirements are met, RunDeck can be installed
either from source, system package or via the launcher.
.SS System Requirements
.PP
The following operating systems are known to support RunDeck:
.IP \[bu] 2
Linux: Most recent distributions are likely to work
.IP \[bu] 2
Windows: XP, Server and above
.IP \[bu] 2
Mac OS X 10.4 or later
.IP \[bu] 2
Solaris or OpenSolaris
.PP
Root (or Administrator on Windows) is not required or recommended.
We recommend using a dedicated user account such as
\[lq]rundeck\[rq].
.PP
If there is need for root access, please set up the RunDeck user to
have access via sudo.
.SS Java
.PP
RunDeck is a Java-Servlet based server and therefore requires the
Java runtime.
.PP
The install process requires that the latest version of Java 1.5 or
1.6 be installed.
Both the Open JDK (http://openjdk.java.net/) and
Sun/Oracle (http://java.com/) JVMs can be used.
You must have the JAVA_HOME environment variable defined in your
environment before running the install script.
.PP
Verify your Java version to check it meets the requirement:
.IP
.nf
\f[C]
$\ java\ -version
java\ version\ "1.6.0_22"
Java(TM)\ SE\ Runtime\ Environment\ (build\ 1.6.0_22-b04-307-10M3261)
Java\ HotSpot(TM)\ 64-Bit\ Server\ VM\ (build\ 17.1-b03-307,\ mixed\ mode)
\f[]
.fi
.SS Network access
.PP
Cients should be set up to allow the RunDeck server user to connect
to the clients using SSH via public-key authentication.
It should not prompt for a password.
There are various ways of installing SSH on Windows; we recommend
Cygwin (http://www.cygwin.com/).
.PP
TCP ports 8080 and 1055 need to be open on the server.
In addition, TCP port 22 needs to be open on the clients for SSH.
.PP
To check the ports are free on a Unix host run:
.IP
.nf
\f[C]
netstat\ -an\ |\ egrep\ \[aq]8080|1055\[aq]\ 
\f[]
.fi
.PP
If the ports are in use on the server, you will see output similar
to below:
.IP
.nf
\f[C]
tcp46\ \ \ \ \ \ 0\ \ \ \ \ \ 0\ \ *.8080\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *.*\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ LISTEN
tcp46\ \ \ \ \ \ 0\ \ \ \ \ \ 0\ \ *.1055\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *.*\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ LISTEN
\f[]
.fi
.PP
The installation procedures describe how to choose different ports,
if there is a conflict.
.SS Installing from Source
.PP
Checkout the sources from GitHub:
https://github.com/dtolabs/rundeck
.PP
Run the build script:
.IP
.nf
\f[C]
./build.sh
\f[]
.fi
.PP
Build clean
.IP
.nf
\f[C]
./build.sh\ -clean
\f[]
.fi
.SS Installing on Linux
.PP
If you want to install RunDeck on Linux via a binary installer, you
can generally do so through the basic package-management tool that
comes with your distribution.
If you’re on Fedora, you can use yum:
.IP
.nf
\f[C]
$\ yum\ install\ rundeck
\f[]
.fi
.SS Installing on other platforms
.PP
Use the launcher as an alternative to a system package:
.IP "1." 3
Download the launcher jar file.
.IP "2." 3
Create a directory for the installation.
.RS 4
.IP
.nf
\f[C]
mkdir\ $HOME/rundeck\ 
\f[]
.fi
.RE
.IP "3." 3
Copy the launcher jar to the installation directory.
.RS 4
.IP
.nf
\f[C]
cp\ rundeck-launcher-1.0.0.jar\ $HOME/rundeck
\f[]
.fi
.RE
.IP "4." 3
Change directory and start the jar.
.RS 4
.IP
.nf
\f[C]
cd\ $HOME/rundeck\ \ \ \ 
/usr/bin/java\ -jar\ rundeck-launcher-1.0.0.jar
\f[]
.fi
.RE
.IP "5." 3
Wait for the Started message.
.RS 4
.IP
.nf
\f[C]
2010-11-19\ 13:35:51.127::INFO:\ \ Started\ SocketConnector\@0.0.0.0:8080
\f[]
.fi
.RE
.SS First-Time Setup
.SS Logins
.PP
RunDeck supports a number of user directory configurations.
By default, the installation uses a file based directory, but
connectivity to LDAP is also available.
.PP
The RunDeck installation process will have defined a set of initial
logins useful during the getting started phase.
.IP \[bu] 2
admin: Belongs to the \[lq]admin\[rq] group and is automatically
granted the \[lq]admin\[rq] role privileges.
.IP \[bu] 2
deploy: Has access to run commands and jobs but unable to modify
job definitions.
.SS Getting Help
.PP
RunDeck includes a set of Unix manual pages describing the shell
tools.
.PP
For Linux users read the introductory man page:
.IP
.nf
\f[C]
$\ man\ rundeck
\f[]
.fi
.PP
For those who installed the launcher add the man pages to your
MANPATH
.IP
.nf
\f[C]
MANPATH=$MANPATH:$HOME/rundeck/man
\f[]
.fi
.SS Summary
.PP
You should have a basic understanding of what RunDeck.
You should also now have a working version of RunDeck on your
system that’s set up with your personal identity.
It’s now time to learn some RunDeck basics.
.PP
% RUNDECK(1) RunDeck User Manuals | Version 1.0 % Alex Honor %
November 20, 2010
.SH RunDeck Basics
.SS Project Setup
.PP
A RunDeck \[lq]Project\[rq] provides a space to manage related
management activities.
.PP
!!!! \f[I]TODO\f[]: Show Create a project menu item in gui
.PP
The rd-project shell tool is used to create the workspace for each
project.
.PP
On the RunDeck server, run the rd-project command and specify a
project name, here we use \[lq]demo\[rq]:
.IP
.nf
\f[C]
rd-project\ -a\ create\ -p\ demo
\f[]
.fi
.PP
This will create the \[lq]demo\[rq] Project configuration in the
server, and generate a bootstrap resource model containing
information about the RunDeck server's host.
.SS Resource model
.PP
The initial resource model generated by rd-project will contain
information just about the RunDeck server host and is used just for
bootstrapping the project.
.PP
You can list the Node resources in a project resource model using
the shell tool, dispatch.
Specify project name using the -p project option.
.PP
Here the dispatch command lists the registered server for the
\[lq]demo\[rq] project after the project setup.
The -v gives a verbose listing that includes more detail:
.IP
.nf
\f[C]
$\ dispatch\ -p\ demo\ -v\ \ \ 
\ strongbad:
\ \ \ \ hostname:\ strongbad
\ \ \ \ os-arch:\ x86_64
\ \ \ \ os-family:\ unix
\ \ \ \ os-name:\ Mac\ OS\ X
\ \ \ \ os-version:\ 10.6.2
\ \ \ \ tags:\ []
\ \ \ ----\ Attributes\ ----
\f[]
.fi
.PP
Node resources have standard properties, such as \[lq]hostname\[rq]
but these can be extended via attributes.
One of the more useful properties is the \[lq]tags\[rq] property.
A tag is a text label that you give to the Node, perhaps denoting a
classification, a role the node plays in the environment, or group
membership.
.PP
The output above shows the \[lq]strongbad\[rq] node currently has
an empty tags property: tags: [].
.PP
It is useful to start thinking about node tagging for the nodes you
manage because you will use them later when specifying filtering
options to drive distributed command dispatch.
.PP
Each Project has its configuration located in its own directory
located in path like:
$RD_BASE/projects/\f[I]project\f[]/etc/project.properties.
.PP
This configuration contains two important properties for accessing
and storing resource model data:
.IP \[bu] 2
project.resources.file: File path to store resource model data.
.IP \[bu] 2
project.resources.url: URL to the server providing the resource
model data.
.PP
You can configure RunDeck to retrieve and store resource model data
from any source, so long as it meets the RunDeck resource model
document requirement.
.PP
RunDeck reads the XML document retrieved from the
${project.resources.url} site and stores it in the path defined by
${project.resources.file}.
.PP
Here's the XML document stored for the \[lq]demo\[rq] project that
corresponds to the output printed by the dispatch -v shown earlier:
.IP
.nf
\f[C]
<project>
\ \ \ \ <node\ name="strongbad"\ type="Node"\ 
\ \ \ \ \ \ description="the\ RunDeck\ server\ host"\ tags=""\ 
\ \ \ \ \ \ hostname="strongbad"\ 
\ \ \ \ \ \ osArch="x86_64"\ osFamily="unix"\ osName="Mac\ OS\ X"\ osVersion="10.6.2"
\ \ \ \ \ \ username="alexh"\ 
\ \ \ \ \ \ editUrl=""\ remoteUrl=""/>
</project>
\f[]
.fi
.PP
Chances are you are maintaining information about your hosts within
another tool, perhaps Chef, Puppet, Nagios, Amazon EC2, RightScale
or even an in-house database.
One of these other tools might be considered the authorative source
of knowledge about the nodes deployed in your network, therefore it
is best to create an interface to one of these tools and expose it
as a web service to RunDeck.
This could be done as a simple CGI script that does a
transformation from the tool's format to the one RunDeck
understands.
.PP
Of course, a rudimentary alternative is to maintain this
information in an XML document you maintain in a source repository
that is periodically exported to Rundeck.
This method could be practical if your host infrastructure rarely
changes.
.PP
The \[lq]resource-v10\[rq] manual contains reference information
about the RunDeck resources document content and structure.
.PP
Check the RunDeck web site for providers to the RunDeck resource
model.
.SS RunDeck Interfaces
.PP
RunDeck provides two primary user interfaces:
.IP \[bu] 2
A HTML-based graphical console running as a webapp
.IP \[bu] 2
A suite of shell tools
.PP
Both interfaces allow you to view resources, dispatch commands, as
well as, store and run jobs.
.SS Graphical Console
.PP
To get started, go to the URL for your RunDeck server.
Login to the web app with the credentials defined by the RunDeck
user directory configuration.
(The default installation username/password is: default/default)
.SS Navigation
.PP
The RunDeck page header contains global navigation control to move
between browsing Jobs, Events and Resources.
It also has links to logout and view the user's profile.
.TP
.B Resources
The Resources page displays the Node resources configured in your
Project resource models.
Like the Jobs and Events pages a filter control can be used to
limit the listing to just the Node resources matching the criteria.
.RS
.RE
.TP
.B Events
From the Events page, one can view currently executing commands in
the \[lq]Now Running\[rq] area or browse execution history.
The execution history can be filtered based on user selected
parameters.
Once the filter has been set, the matching history is displayed.
The current filter settings also configure an RSS link, found in
the top right of the page.
.RS
.RE
.TP
.B Jobs
From the Jobs page, one can list, create and run Jobs.
A configurable filter allows a user to limit the Job listing to
those Jobs matching the filtering criteria.
These filter settings can be saved to a Users profile.
.RS
.RE
.TP
.B Admin
If your login belongs to the \[lq]admin\[rq] group and therefore
granted \[lq]admin\[rq] priveleges, a wrench icon will be displayed
next to your login name.
This page allows the admin to view group memberships for all users,
as well as, edit their profile data.
.RS
.RE
.TP
.B Project menu
By default information about all projects is displayed.
It is sometimes preferable to limit this information to just a
particular project.
The top navigation bar contains a menu to select the desired
project.
.RS
.RE
.SS Shell Tools
.PP
RunDeck includes a number of shell tools to dispatch commands, load
and run Job definitions and interact with the execution queue.
These are an alternative to those same functions accessible in the
graphical console.
.TP
.B dispatch
Execute ad hoc commands and scripts
.RS
.RE
.TP
.B rdq
Query the dispatcher for currently running Jobs and possibly kill
them
.PD 0
.P
.PD

.RS
.RE
.TP
.B rd-jobs
List defined jobs as well as load them from text file definitions
.RS
.RE
.TP
.B run
Invoke the execution of a stored Job
.RS
.RE
.TP
.B rd-project
Setup a new RunDeck project
.RS
.RE
.TP
.B rd-setup
(Re-)configure an instance of RunDeck
.RS
.RE
.PP
Consult the online manual pages for options and usage information.
.SS Command Execution
.PP
RunDeck supports two modes of execution: \f[I]ad-hoc\f[] commands
and \f[I]Job\f[].
.PP
An \f[I]ad hoc\f[] command is any system command or shell script
executed via the command dispatcher.
Ad hoc commands can be executed via a command line utility named
dispatch or as a Job run from the graphical console.
.PP
A \f[I]Job\f[] specifies a sequence of one or more command
invocations that can be run once (i.e, is temporary) or named and
stored for later use.
Stored jobs can be started via the shell tool, run, and their
progress checked with rdq.
.SS Dispatcher options
.PP
Dispatcher execution can be controlled by various types of options.
.TP
.B Execution control
Command execution can be controlled in various ways.
Concurrency is controlled through threadcount.
Execution can continue if specified to keepgoing
.RS
.RE
.TP
.B Include and exclude patterns
Filtering options specify include and exclude patterns to determine
which nodes from the project resource model to distribute commands.
.RS
.RE
.TP
.B Keywords
Keywords are used within they include and exclude patterns.
The \[lq]tags\[rq] keywords additionally can use a boolean operator
to combine logical ORs and ANDs.
.RS
.RE
.TP
.B Option combination
All keywords can be combined by specifying the include and exclude
options multiple times on the command line.
.RS
.RE
.PP
One can experiment querying the resource model in the graphical
console or with the dispatch tool.
.SS Filtering nodes in the shell
.PP
dispatch can use the commandline options -I (include) and -X
(exclude) to specify which nodes to include and exclude from the
base set of nodes.
You can specify a single value, a list of values, or a regular
expression as the argument to these options.
.PP
\f[I]Examples\f[]
.PP
List nodes with OS name, Linux:
.IP
.nf
\f[C]
dispatch\ -p\ demo\ -I\ os-name=Linux
\f[]
.fi
.PP
List Linux nodes but exclude ones with names prefixed
\[lq]web.\[rq]:
.IP
.nf
\f[C]
dispatch\ -p\ demo\ -I\ os-name=Linux\ -X\ "web.*"
\f[]
.fi
.PP
List nodes that are tagged both \[lq]web\[rq] and \[lq]prod\[rq] :
.IP
.nf
\f[C]
dispatch\ -p\ demo\ -I\ tags=web+prod
\f[]
.fi
.PP
Execute the apachectl restart command in 10 threads across all
nodes tagged \[lq]web\[rq] and keepgoing in case an error occurs :
.IP
.nf
\f[C]
dispatch\ -p\ demo\ -I\ tags=web\ -K\ -C\ 10\ --\ sudo\ apachectl\ restart\ 
\f[]
.fi
.PP
Consult the \[lq]rd-options(1)\[rq] manual page for the complete
reference on available dispatcher options.
.SS Filtering nodes graphically
.PP
!!! TODO !!!
.SS Ad-hoc commands
.PP
Typically, an \[lq]ad hoc\[rq] command is a shell script or system
executable that you run at an interactive terminal.
Ad hoc commands can be executed via the dispatch shell command or a
graphical shell.
.SS Shell tool command execution
.PP
Use dispatch to execute individual commands or shell script files.
.PP
Here dispatch is used to run the Unix uptime command to print
system status:
.IP
.nf
\f[C]
$\ dispatch\ -I\ os-family=unix\ --\ uptime
[ctier\@centos54\ dispatch][INFO]\ \ 10:34:54\ up\ 46\ min,\ \ 2\ users,\ \ load\ average:\ 0.00,\ 0.00,\ 0.00
[alexh\@strongbad\ dispatch][INFO]\ 10:34\ \ up\ 2\ days,\ 18:51,\ 2\ users,\ load\ averages:\ 0.55\ 0.80\ 0.75
[demo\@ubuntu\ dispatch][INFO]\ \ 10:35:01\ up\ 2\ days,\ 18:40,\ \ 2\ users,\ \ load\ average:\ 0.00,\ 0.01,\ 0.00
\f[]
.fi
.PP
Notice, the dispatch command prepends the message output with a
header that helps understand from where the output originates.
The header format includes the login and node where the dispatch
execution occurred.
.PP
Execute the Unix whomi command to see what user ID is used by that
Node to run dispatched commands:
.IP
.nf
\f[C]
$\ dispatch\ -I\ os-family=unix\ --\ whoami
[ctier\@centos54\ dispatch][INFO]\ ctier
[alexh\@strongbad\ dispatch][INFO]\ alexh
[demo\@ubuntu\ dispatch][INFO]\ demo
\f[]
.fi
.PP
You can see that the resource model defines each Node to use a
different login to execute dispatch commands.
That feature can be handy when Nodes serve different roles and
therefore, use different logins to manage processes.
See the username attribute in \[lq]resource-v10(1)\[rq] manual
page.
.PP
The dispatch command can also execute shell scripts.
Here's a trivial script that generates a bit of system info:
.IP
.nf
\f[C]
#!/bin/sh
echo\ "info\ script"
echo\ uptime=`uptime`
echo\ whoami=`whoami`
echo\ uname=`uname\ -a`
\f[]
.fi
.PP
Use the -s option to specify the \[lq]info.sh\[rq] script file:
.IP
.nf
\f[C]
$\ dispatch\ -I\ os-family=unix\ -s\ info.sh
\f[]
.fi
.PP
The dispatch command copies the \[lq]info.sh\[rq] script located on
the server to each \[lq]unix\[rq] Node and then executes it.
.SS Graphical command shell execution
.PP
The RunDeck graphical console also provides the ability to execute
ad-hoc commands to a set of filtered Node resources.
The command prompt can accept any ad-hoc command string you might
run via an SSH command or via the dispatch shell tool.
.PP
But before running any commands, you need to select the project
containing the Nodes you wish to dispatch.
Use the project menu to select the desired project name.
After the project has been selected you will see a long horizontal
textfield labeled \[lq]Command\[rq].
This is the RunDeck command prompt tool bar.
.PP
To use the command prompt, type the desired ad-hoc command string
into the textfield and press the \[lq]Run\[rq] button.
The command will be dispatched to all the Node resources currently
listed below the command prompt tool bar.
.PP
If the project selection menu was just chosen, then all Node
resources in that project resource model will be listed.
You will most likely want to limit the execution of your ad-hoc
command to a subset of these.
.PP
Use the filter control to refine the list of Nodes to target for
your ad-hoc command.
Press the \[lq]Filter\[rq] link to open the filter control form.
Inside the filter form you will see an area to define an include
filter expression and a link to \[lq]Extended Filters\&...\[rq]
where an exclusion expression can also be defined.
Many simple cases can use either a regex pattern on Node name or a
tag expression.
Type in the desired filter expression and press the
\[lq]Filter\[rq] button to refine the Node listing and redisplay
the command prompt tool bar.
.PP
Once you are satisifed with the Node listing, input the ad-hoc
command string, then press the \[lq]Run\[rq] button to begin
execution.
The browser will be directed to a page where execution output can
be followed.
.SS Following execution output
.PP
Command execution is displayed on a spearate page.
This page provides several views to read the output using different
formats.
.TP
.B Tail Output
Displays output messages from the command execution as if you were
running the Unix tail -f command on the output log file.
By default, only the last 20 lines of output is displayed but this
can be expanded or reduced by pressing the \[lq]-\[rq] or
\[lq]+\[rq] buttons.
You can also type in an exact number into the textfield.
.RS
.RE
.TP
.B Annotated
The annotated mode displays the output messages in the order they
are received but labels the each line with the Node from which the
message originated.
Through its additional controls each Node context can be expanded
to show the output it produced, or completely collapsed to hide the
textual detail.
.RS
.RE
.TP
.B Node Output
Output messages are sorted into Node specific sections and are not
interlaced.
By default, the messages are collapsed but can be revealed by
pressing the disclosure icon to the right.
.RS
.RE
.PP
Also, notice the URL in the location bar of your browser.
This URL can be shared to others interested in the progress of
execution.
The URL contains the execution ID (EID) and has a form like:
.IP
.nf
\f[C]
\ http://rundeckserver/execution/follow/{EID}
\f[]
.fi
.PP
After execution completes, the command will have a status:
.IP \[bu] 2
Successful: No errors occurred during execution of the command
across the filtered Node set
.IP \[bu] 2
Failed: One or more errors occurred.
A list of Nodes that incurred an error is displayed.
The page will also contain a link \[lq]Retry Failed Nodes\&...\[rq]
in case you would like to retry the command.
.PP
A URL also exists for this page which can be used later to refer to
this execution:
.IP
.nf
\f[C]
\ http://rundeckserver/execution/show/{EID}
\f[]
.fi
.PP
You can download the entire output as a text file from this page.
Press the \[lq]Download\[rq] link to retrieve the file to your desk
top.
.SS Controlling ad-hoc command execution
.PP
Parallel execution is managed using thread count via \[lq]-C\[rq]
option.
The \[lq]-C\[rq] option specifies to the number of execution
threads.
Here's an example that runs the uptime command across the Linux
hosts with two threads:
.IP
.nf
\f[C]
dispatch\ -I\ os-name=Linux\ -C\ 2\ --\ uptime
\f[]
.fi
.PP
The keepgoing and retry flags control when to exit incase an error
occurs.
Use \[lq]-K/-R\[rq] flags.
Here's an example script that checks if the host has port 8080 in
the listening state.
If it does not, it will exit with code 1.
.IP
.nf
\f[C]
#!/bin/sh
netstat\ -an\ |\ grep\ 8080\ |\ grep\ -q\ LISTEN
if\ [\ "$?"\ !=\ 0\ ];\ then
echo\ "not\ listening\ on\ 8080"
exit\ 1;
fi
echo\ \ listening\ port=8080,\ host=`hostname`;
\f[]
.fi
.PP
Commands or scripts that exit with a non-zero exit code will cause
the dispatch to fail unless the keepgoing flag is set.
.IP
.nf
\f[C]
$\ dispatch\ -I\ os-family=unix\ -s\ /tmp/listening.sh
[alexh\@strongbad\ dispatch][INFO]\ Connecting\ to\ centos54:22
[alexh\@strongbad\ dispatch][INFO]\ done.
[ctier\@centos54\ dispatch][INFO]\ not\ listening\ on\ 8080
error:\ Remote\ command\ failed\ with\ exit\ status\ 1
The\ script\ failed\ on\ centos54\ and\ caused\ dispatch\ to\ error\ out\ immediately.
\f[]
.fi
.PP
Running the command again, but this time with the \[lq]-K\[rq]
keepgoing flag will cause dispatch to continue and print on which
nodes the script failed:
.IP
.nf
\f[C]
$\ dispatch\ -K\ -I\ tags=web\ -s\ /tmp/listening.sh
[alexh\@strongbad\ dispatch][INFO]\ Connecting\ to\ centos54:22
[alexh\@strongbad\ dispatch][INFO]\ done.
[ctier\@centos54\ dispatch][INFO]\ not\ listening\ on\ 8080
[ctier\@centos54\ dispatch][ERROR]\ Failed\ execution\ for\ node:\ centos54:\ Remote\ command\ failed\ with\ exit\ status\ 1
[alexh\@strongbad\ dispatch][INFO]\ listening\ port=8080,\ host=strongbad
[alexh\@strongbad\ dispatch][INFO]\ Connecting\ to\ 172.16.167.211:22
[alexh\@strongbad\ dispatch][INFO]\ done.
[demo\@ubuntu\ dispatch][INFO]\ not\ listening\ on\ 8080
[demo\@ubuntu\ dispatch][ERROR]\ Failed\ execution\ for\ node:\ ubuntu:\ Remote\ command\ failed\ with\ exit\ status\ 1
error:\ Execution\ failed\ on\ the\ following\ 2\ nodes:\ [centos54,\ ubuntu]
error:\ Execute\ this\ command\ to\ retry\ on\ the\ failed\ nodes:
\ \ \ \ dispatch\ -K\ -s\ /tmp/listening.sh\ -p\ demo\ -I
\ \ \ \ name=centos54,ubuntu
\f[]
.fi
.SS Queuing commands to RunDeck
.PP
Commands or scripts executed on the command line by dispatch can
also be queued as temporary jobs in RunDeck by using the
\[lq]-Q\[rq] option.
The dispatch -Q usage is equivalent to a \[lq]Run and Forget\[rq]
action in the graphical console.
.PP
The script below is a long running check that will conduct a check
periodically waiting a set time between each pass.
The script can be run with or without arguments as the parameters
are defaulted inside the script:
.IP
.nf
\f[C]
$\ cat\ ~/bin/checkagain.sh\ 
#!/bin/bash
iterations=$1\ secs=$2\ port=$3
echo\ "port\ ${port:=8080}\ will\ be\ checked\ ${iterations:=30}\ times\ waiting\ ${secs:=5}s\ between\ each\ iteration"\ 
i=0
while\ [\ $i\ -lt\ ${iterations}\ ];\ do
\ \ echo\ "iteration:\ #${i}"
\ \ netstat\ -an\ |\ grep\ $port\ |\ grep\ LISTEN\ &&\ exit\ 0
\ \ echo\ ----
\ \ sleep\ ${secs}
\ \ i=$(($i+1))
done
echo\ "Not\ listening\ on\ $port\ after\ $i\ checks"\ ;\ exit\ 1
\f[]
.fi
.PP
Running dispatch with the -Q option causes the execution to queue
in RunDeck and controlled as temporary Job.
The -I centos54 limits execution to just the \[lq]centos54\[rq]
node:
.IP
.nf
\f[C]
$\ dispatch\ -Q\ -I\ centos54\ -s\ ~/bin/checkagain.sh\ 
Succeeded\ queueing\ workflow:\ Workflow:(threadcount:1){\ [command(\ scriptfile:\ /Users/alexh/bin/checkagain.sh)]\ }
Queued\ job\ ID:\ 5\ <http://strongbad:8080/execution/follow/4>
\f[]
.fi
.PP
To pass arguments to the script pass them after the \[lq]--\[rq]
(double dash):
.IP
.nf
\f[C]
$\ iters=5\ secs=60\ port=8080
$\ dispatch\ -Q\ -I\ centos54\ -s\ ~/bin/checkagain.sh\ --\ $iters\ $secs\ $ports
\f[]
.fi
.SS Tracking execution
.PP
Queued ad-hoc command and temporary or saved Job executions can be
tracked from the \[lq]Events\[rq] page in the \[lq]Now Running\[rq]
area at the top of the page.
.PP
This page provides a listing of all running executions, when they
started, who started them and an approximation of their completion
progress.
.PP
Users with \[lq]workflow_kill\[rq] privilege, will also see a link
to kill the Job in case they want to stop it immediatly.
.PP
Execution can also be tracked using the rdq shell tool.
.IP
.nf
\f[C]
$\ rdq
Queue:\ 1\ items
[5]\ workflow:
Workflow:(threadcount:1){[command(\ scriptfile:\ /Users/alexh/bin/checkagain.sh)]
}\ <http://strongbad:8080/execution/follow/5>
\f[]
.fi
.PP
Running jobs can also be killed via the rdq \[lq]kill\[rq] command.
The rdq command includes the execution ID for each running job.
Specify execution ID using the \[lq]-e\[rq] option:
.IP
.nf
\f[C]
$\ ctl-queue\ kill\ -e\ 5
ctl-queue\ kill:\ success.\ [5]\ Job\ status:\ killed
\f[]
.fi
.PP
Show now running page\&...
.SS History
.PP
History for queued ad-hoc commands, as well as, temporary and saved
Job executions is stored in by the RunDeck server.
History data can be filtered and viewed inside the \[lq]Events\[rq]
page of the graphical console.
.SS Filtering event history
.PP
By default, the Events page will list history for the last day's
executions.
The page contains a filter control that can be used to expand or
limit the executions.
.PP
The filter form contains a number of fields to limit search:
.IP \[bu] 2
Within: Time range.
Choices include 1 day, 1 week, 1 month or other (given a start
after/before to ended after/before).
.IP \[bu] 2
Job Name: Job title name.
.IP \[bu] 2
Project: Project name.
This may be set if the project menu was used.
.IP \[bu] 2
Resource: Name of project resource.
.IP \[bu] 2
User: User initiating action.
.IP \[bu] 2
Node: Node name.
.IP \[bu] 2
Tags: Event tag name.
.IP \[bu] 2
Report ID: Report identifier.
.IP \[bu] 2
Message: Message text.
.IP \[bu] 2
Result: Success or failure status.
.PP
After filling the form pressing the \[lq]Filter\[rq] button, the
page will display events matching the search.
.PP
Filters can be saved to a menu that makes repeating searches more
convenient.
Click the \[lq]save this filter\&...\[rq] link to save the filter
configuration.
.SS Event view
.PP
History for each execution contains the command(s) executed,
dispatcher options, success status and a link to a file containing
all the output messages.
.SS RSS Link
.PP
An RSS icon provides a link to an RSS view of the events that match
the current filtering critera.
.SS Tips and Tricks
.SS Saving filters
.PP
Each of the filter controls provides the means to save the current
filter configuration.
Press the \[lq]save this filter\&...\[rq] link to give it a name.
Each saved filter is added to a menu you can access the next time
you want that filter configuration.
.SS Auto-Completion
.PP
If you use the Bash shell, RunDeck comes with a nice
auto-completion script you can enable.
Add this to your \f[C].bashrc\f[] file:
.IP
.nf
\f[C]
source\ ~/$RD_HOME/etc/rundeck-completion.bash
\f[]
.fi
.PP
Press the Tab key when you're writing a Git command, and it should
return a set of suggestions for you to pick from:
.IP
.nf
\f[C]
$\ dispatch\ <tab><tab>
\f[]
.fi
.SS Summary
.PP
At this point, you can do basic RunDeck operations - setup a
project, define and query the project resource model, execute
ad-hoc commands, run and save Jobs and view history.
.PP
Next, we'll cover one of RunDeck's core features: Jobs.
.PP
% RUNDECK(1) RunDeck User Manuals | Version 1.0 % Alex Honor %
November 20, 2010
.SH Jobs
.PP
In previous sections of this manual, you learned how to execute
ad-hoc commands across a filtered set of Node resources.
This chapter introduces a fundamental RunDeck feature,
\f[I]Jobs\f[].
But first, one might ask why introduce another layer over ad-hoc
command execution.
.PP
Here are some issues that might arise over time:
.IP \[bu] 2
One might find certain ad-hoc command executions are repeated, and
perhaps, represent what has become a routine procedure.
.IP \[bu] 2
Another user in your group needs a simple self-service interface to
run a procedure across a set of nodes.
.IP \[bu] 2
Routine procedures need to be encapsulated and be the basis for
other routine procedures.
.PP
Jobs provide a means to encapsulate a procedure in a logically
named Job.
A \f[I]Job\f[] is a configuration representing the steps in a
procedure, a Node filter specification, and dispatcher execution
control parameters.
Jobs access is governed by an access control policy that describes
how users are granted authorization to use Jobs.
.PP
RunDeck lets you organize and execute Jobs, and observe the output
as the Job is running.
You can view a list of the currently running Jobs that is
dynamically updated as the Jobs progress.
Jobs can also be killed if they need to be stopped.
.PP
Each Job has a record of every time it has been executed, and the
output from those executions can be viewed.
.PP
The next sections describes how to navigate and run existing Jobs.
In later sections, the topic of Job creation will be covered.
.PP
If you want to skip ahead, you can go straight to
Creating Jobs (#creating-jobs).
.SS Job groups
.PP
As many jobs will accumulate over time, it is useful to organize
Jobs into groups.
A group is a logical set of jobs, and one job group can exist
inside another.
RunDeck displays job lists as a set of folders corresponding to the
group structure your jobs define.
.PP
Beyond organizing jobs, groups assist in defining access control
policy, as we'll cover later in the Authorization chapter.
.SS Listing and filtering Jobs
.PP
All Job activity begins on the main \[lq]Jobs\[rq] page inside
RunDeck.
After logging in, press the \[lq]Jobs\[rq] button in the top
navigation bar and any Jobs you are authorized to see will be
displayed.
.PP
If the Jobs were defined inside groups, you will see the listing
grouped into a folder like structure.
These folders represent the Job groups described earlier.
You can navigate these folders by pressing the folder icon to
reveal its contents.
.PP
Once you have navigated to a Job, you will see its name, possibly
its description and a summary total of how many times it has been
executed.
.PP
Clicking on the job name will will expand the window to show the
Job detail.
You will see a button bar containing icons representing the actions
you are able to perform.
Other Job detail will include what command(s) it will run, filter
expressions and other dispatcher options.
.SS Filtering Jobs
.PP
The Job page lets you search for Jobs using the Filter option.
.PP
Click the \[lq]Filter\[rq] link to show the filter options:
.PP
This will show the Filter fields:
.PP
Enter a value in any of the filter fields:
.IP \[bu] 2
Job Name: the name of the job
.IP \[bu] 2
Group: the name of the job group
.IP \[bu] 2
Description: Job description text
.PP
You can type a substring or a regular expression in any of these
fields.
.PP
After pressing the \[lq]Filter\[rq] button, the Job list will be
filtered to include only the matching jobs.
.PP
To refine the filter, click on the blue-outlined Filter
description, and change the filter fields.
.PP
To reset the filter and go back to the full job page, click the
\[lq]Clear\[rq] button in the Filter fields.
.SS Running a Job
.PP
Any stored job can be started from the Job page by pressing the
green \[lq]Run\[rq] icon in the Job control bar.
If you do not see the Run icon, it means your login does not have
\[lq]run\[rq] privileges.
.PP
Jobs can also be started from the command line using the run shell
tool.
.PP
Here's an example that starts a hypothetical job named
\[lq]restart\[rq] belonging in the \[lq]apps/web\[rq] Job group:
.IP
.nf
\f[C]
$\ run\ -j\ apps/web/restart
Job\ execution\ started:
[51]\ restart\ <http://strongbad:8080/execution/follow/51>
\f[]
.fi
.PP
After the Run button has been pressed the page will be directed to
choose execution options.
.SS Choose execution options
.PP
Jobs can be defined to prompt the user for options.
This page contains a form presenting any of these Job options.
.PP
Some options will have default values while others may present you
with a menu of choices.
Some options are optional while others are required.
Lastly, their might be a pattern govering what values are
acceptable.
.PP
If there are any such Job options, you can change them here before
proceeding with the execution.
.PP
When you are ready press \[lq]Run Job Now\[rq] page and you will be
directed to page where you can follow the progress of the Job.
You can press the \[lq]Cancel\[rq] button
.SS Following Running Jobs
.PP
Once you have started running a Job, you can follow the output of
the job in the Execution Follow page.
.PP
Depending where you are in the RunDeck console, you can track a
running Job starting from several locations:
.IP \[bu] 2
If you have just pressed the Run button for a Job and chose its
execution options and pressed \[lq]Run Job Now\[rq] you will
automatically be directed to this page.
.IP \[bu] 2
From the Jobs page, you can click to the Job you are interested in
tracking and click the spinning cursor icon labeled \[lq]now\[rq].
.IP \[bu] 2
From the Events page, open the \[lq]Now Running\[rq] area adn then
click on the \[lq]output »\[rq] link for the running execution.
.SS Creating Jobs
.PP
With RunDeck you can define two kinds of Jobs.
.IP \[bu] 2
Temporary: A temporary Job defines a set of commands to execute and
a node filter configuration.
.IP \[bu] 2
Saved: Saved jobs also define a set of commands to execute and
dispatcher options but can be given a name and stored in a group.
Additionally, saved Jobs can be given an execution schedule.
.SS Temporary Jobs
.PP
A temporary job is a bit like an ad-hoc command except you get more
controls about how the commands will execute plus the execution can
be tracked tracked within the RunDeck webapp.
.PP
To create a temporary job, begin by logging in to the RunDeck
webapp, and press the \[lq]Jobs\[rq] tab.
.IP "1." 3
Locate the \[lq]New Job\[rq] button in the right hand corner and
press it to display the \[lq]Create New Job\[rq] form.
.IP "2." 3
A job is defined in terms of one or more workflow items.
In the Workflows area, click the \[lq]Add an item\[rq] link.
.IP "3." 3
Workflow items can be one of several types.
Click the \[lq]Script\[rq] workflow item type.
.IP "4." 3
A script type can be any script that can be executed on the target
hosts.
Type in the \[lq]info\[rq] shell script we executed earlier using
dispatch.
.IP "5." 3
At the bottom of the form, push the \[lq]Run and Forget\[rq] button
to begin execution.
.IP "6." 3
Execution output can be followed on the subsequent page.
.SS Saved Jobs
.PP
Running ad hoc commands and temporary jobs are a typical part of
day to day administrative tasks.
Occasionally, ad-hoc commands become routine procedures and if were
reusable, would become valuable as they could be handed off to
others in the team or invoked from within other Jobs.
RunDeck provides an interface to declare and save jobs, both
graphically or declared with an XML file.
.SS Simple saved job
.PP
For the first saved Job example, create a Job that calls the info
script.
.IP "1." 3
Like in the earlier example, begin by pressing the
\[lq]New Job\[rq] button.
.IP "2." 3
Within the new job form:
.RS 4
.IP \[bu] 2
Select \[lq]Yes\[rq] for the \[lq]Save this job?\[rq] prompt.
Pressing Yes reveals a form to define a name, group and description
for the job.
.IP \[bu] 2
For \[lq]Job Name\[rq], enter \[lq]info\[rq] and for the
\[lq]Group\[rq], enter \[lq]adm/resources\[rq].
.IP \[bu] 2
Providing a description will be come helpful to other users to
understand the intent and purpose for the Job.
.IP \[bu] 2
Check the box for \[lq]Dispatch to Nodes\[rq]
.IP \[bu] 2
Choose the \[lq]Node Exclude Filters\[rq] and enter the name of
your RunDeck server.
This will cause the job to run on just the remote Nodes (eg.,
centos54 and ubuntu).
.IP \[bu] 2
Type in the info script that we used earlier.
.IP \[bu] 2
Save the script changes in the Workflow editor.
.IP \[bu] 2
Press the \[lq]Create\[rq] button at the bottom of the page.
.RE
.IP "3." 3
After the the job is created, the browser is directed to the Jobs
page.
The folder structure reflecting the group naming will show one Job.
.RS 4
.IP \[bu] 2
Press through the folders and then to the job itself
.RE
.IP "4." 3
Notice the button bar with controls for editing and running the
job.
.RS 4
.IP \[bu] 2
Press the green arrow icon to run the Job.
.RE
.IP "5." 3
Press the \[lq]Run Job Now\[rq] button to begin execution.
.RS 4
.IP \[bu] 2
Output from the script execution from the target Nodes will be
displayed on the subsequent page.
.RE
.SS Scheduled Jobs
.PP
Saved jobs can be configured to run on a periodic basis.
If you want to create a Scheduled Job, select Yes under
\[lq]Schedule to run repeatedly?\[rq]
.PP
The schedule can be defined in a simple graphical chooser or Unix
crontab format.
.PP
To use the simple chooser, choose an hour and minute.
You can then choose \[lq]Every Day\[rq] (default), or uncheck that
option and select individual days of the week.
You can select \[lq]Every Month\[rq] (default) or unselect that
option and choose specific months of the year:
.PP
If the crontab time and date format is preferred, enter a cron
expression.
.PP
The exact crontab syntax used is referenced here:
CronExpression (http://www.quartz-scheduler.org/docs/api/1.8.1/org/quartz/CronExpression.html)
.SS Job history
.PP
In the Jobs page, you can see the outcome of previous executions of
Jobs by clicking the \[lq]Executions\[rq] link for the Job.
This returns a filtered history peraining to that Job.
You can click on any past execution in the list to see the full
execution state.
.SS Killing Jobs
.PP
Jobs that are currently running can be Killed immediately.
.PP
WARNING: This feature should be used with caution, as it forcibly
kills the Java Thread that the Job is running on.
It may result in the RunDeck server becoming flaky.
It is a deprecated feature of Java that is not recommended to be
used, so do so only when extremely necessary.
.PP
From the Events view Now Running section, or in the Job execution
follow page, click on the \[lq]Kill Job Now\[rq] button for the
running Job.
.PP
When prompted \[lq]Really kill this job?\[rq] Click the
\[lq]Yes\[rq] button.
.PP
The Job will terminate with a \[lq]Killed\[rq] completion status.
.SS Deleting Jobs
.PP
In the Jobs, click the red \[lq]X\[rq] icon for the Job you want to
delete.
.PP
Click \[lq]Yes\[rq] when it says \[lq]Really delete this Job?\[rq]
.SS Updating and copying Jobs
.PP
All of the data you set when creating a job can be modified.
To edit a Job, you can either click the Pencil icon in the Job
list:
.PP
Similarly, to Copy a Job definition to a new Job, choose the Copy
icon or the Copy button.
.SS Exporting Jobs as XML
.PP
Job definitions created inside the RunDeck graphical console can be
exported to an XML file format and be used for later import.
.PP
Two methods exist to retrieve the XML definition one inside
RunDeck's graphical interface and the other using the rd-jobs shell
tool.
.PP
From RunDeck's Job page navigate to the Job you wish to export.
Locate the icon with an XML symbol in the toolbar.
It is labeled \[lq]Download XML\[rq] in the mouse tool tip.
.PP
Press this button to initiate the file download to your browser.
Depending on your browser, it will be stored to your downloads
directory.
.PP
If you prefer the command line open a shell on the RunDeck server.
Run the rd-jobs command to write it to disk.
By default, rd-jobs will dump all Job definitions to one file.
To limit it to just a single Job specify its name:
.IP
.nf
\f[C]
rd-jobs\ -n\ "job-name"\ -f\ jobs.xml
\f[]
.fi
.PP
This will store the results in the \[lq]jobs.xml\[rq] file.
.PP
Consult the \[lq]rd-jobs(1)\[rq] manual page for additional command
usage.
.SS Importing Jobs as XML
.PP
If you have a \[lq]jobs.xml\[rq] file (See above) and want to
upload it via the GUI web interface, you can do so.
.PP
Click on the New Job" button in the Job list.
.PP
In the \[lq]Create New Job\[rq] form, click on the button that says
\[lq]Uplaod Definition\&...\[rq] on the right side:
.PP
Click the Choose File button and choose your jobs.xml file to
upload.
.PP
Choose an option where it says
\[lq]When a job with the same name already exists:\[rq]:
.IP \[bu] 2
Update - this means that a job defined in the xml will overwrite
any existing job with the same name
.PD 0
.P
.PD

.IP \[bu] 2
Skip - this means that a job defined in the xml will be skipped
over if there is an existing job with the same name
.PD 0
.P
.PD

.IP \[bu] 2
Create - this means that the job defined in the xml will be used to
create a new job if there is an existing job with the same name.
.PP
Click the Upload button.
If there are any errors with the Job definitions in the XML file,
they will show up on the page.
.SS Summary
.PP
Next, we'll cover how to create multi-step procedures using Job
Workflows.
.PP
% RUNDECK(1) RunDeck User Manuals | Version 1.0 % Alex Honor %
November 20, 2010
.SH Job Workflows
.PP
The Job's most basic feature is its ability to execute one or more
commands across a set of nodes.
This sequence of commands is called a \f[I]workflow\f[], and each
step in the workflow is defined as an invocation to a command.
.PP
The steps of the Job workflow are displayed when viewing a Job's
detail from a Job listing or within the Job editor form.
.SS Authoring tools
.PP
Workflows can be defined within the RunDeck graphical console or as
an XML document that is loaded to the server.
.PP
The graphical console provides an authoring environment where steps
can be added, edited, removed or reordered.
.PP
Users prefering to define Jobs in XML should read the
\[lq]job-v10(1)\[rq] manual page.
.PP
It is also possible to author Jobs inside the graphical console and
then export the definiton as an XML file using the rd-jobs shell
tool (man \[lq]rd-jobs(1)\[rq]).
.SS Workflow control settings
.PP
Workflow execution is controlled by two important settings:
\f[I]Keepgoing\f[] and \f[I]Strategy\f[].
.PP
\f[I]Keepgoing\f[]: This manages what to do if a step incurs and
error:
.IP \[bu] 2
No: Fail immediately (default)
.IP \[bu] 2
Yes: Continue to next step
.PP
The default is to fail immediately but depending on the procedure
at hand you can choose to have the execution continue.
.PP
\f[I]Strategy\f[]: Controls the order of execution of steps and
command dispatch to nodes: \f[I]Node-oriented\f[] and
\f[I]Step-oriented\f[].
.IP \[bu] 2
\f[I]Node-oriented\f[]: Executes the full workflow on each node
before the next node.
(default)
.IP \[bu] 2
\f[I]Step-oriented\f[]: Executes each step on all nodes before the
next node.
.PP
The following illustrations contrast the strategies showing how
three steps proceed across two nodes.
.PP
Node-oriented flow illustrated:
.IP
.nf
\f[C]
1.\ \ \ NodeA\ \ \ \ step#1
2.\ \ \ \ \ "\ \ \ \ \ \ step#2
3.\ \ \ \ \ "\ \ \ \ \ \ step#3
4.\ \ \ NodeB\ \ \ \ step#1
5.\ \ \ \ \ "\ \ \ \ \ \ step#2
6.\ \ \ \ \ "\ \ \ \ \ \ step#3
\f[]
.fi
.PP
Step-oriented flow illustrated:
.IP
.nf
\f[C]
1.\ \ \ NodeA\ \ \ \ step#1
2.\ \ \ NodeB\ \ \ \ \ \ "
3.\ \ \ NodeA\ \ \ \ step#2
4.\ \ \ NodeB\ \ \ \ \ \ "
5.\ \ \ NodeA\ \ \ \ step#1
6.\ \ \ NodeB\ \ \ \ \ \ "
\f[]
.fi
.PP
The process you are automating will determine which strategy is
correct, though the node-oriented flow is more commonplace.
.SS Workflow steps
.PP
The following sections describe how to construct a workflow as a
set of steps that call commands of different types.
.PP
When creating a new Job definition, the Workflow form will be set
with defaults and have no workflow steps defined.
The workflow editor will have a form open asking to enter a shell
command as the first step.
.PP
To add new steps simply press the \[lq]Add a step\[rq] link inside
the workflow editor form.
This will prompt you with a dialog asking which kind of workflow
step you would like to add.
Each kind of step has its own form.
When you are done filling out the form, press \[lq]Save\[rq] to add
it to the sequence.
Pressing \[lq]Cancel\[rq] will close the form and leave the
sequence unchanged.
.PP
New steps are always added to the end of the sequence.
See Reordering steps (#reordering-steps) for directions on
modifying the step order.
.PP
The next several sections describe the specification of each kind
of command step.
.SS Command step
.PP
Use the command step to call system commands.
This is the default type of workflow step when creating a Job.
Enter any command string you would type at the terminal on the
remote hosts.
.PP
This is similar to calling the command with dispatch:
.IP
.nf
\f[C]
dispatch\ [filter-options]\ --\ command
\f[]
.fi
.SS Script step
.PP
Execute the supplied shell script content.
Optionally, can pass an argument to the script specified in the
lower text field.
.PP
This is similar to calling the command with dispatch:
.IP
.nf
\f[C]
dispatch\ [filter-options]\ --stdin\ --\ args\ <<EOF\ 
script\ content\ here\ 
EOF
\f[]
.fi
.SS Script file step
.PP
Executes the script file local to the sever to the filtered Node
set.
Arguments can be passed to the script by specifying them in the
lower text field.
.PP
This is similar to calling the script file with dispatch:
.IP
.nf
\f[C]
dispatch\ [filter-options]\ -s\ scriptfile\ --\ args
\f[]
.fi
.SS Job reference step
.PP
To call another saved Job, create a Job Reference step.
Enter the name of the Job and its group.
.PP
The Job Reference form provides a Job browser to make it easier to
select from the existing set of saved Jobs.
Click the \[lq]Choose A Job\&...\[rq] link and navigate to the
desired Job.
.PP
Finally, if the Job defines Options, you can specify them in the
commandline arguments text field.
.PP
This is simililar to calling the other Job with run:
.IP
.nf
\f[C]
dispatch\ [filter-options]\ -j\ group/jobname
\f[]
.fi
.SS Reordering steps
.PP
The order of the Workflow steps can be modified by hovering over
any item and then clicking and dragging the double arrow icon to
the desired position.
A blue horizontal bar helps highlight the position where the Job
will land.
.PP
After releasing the select Job, it will land in the desired
position and the step order will be updated.
.PP
If you wish to Undo the step reordering, press the \[lq]Undo\[rq]
link above the steps.
.PP
The \[lq]Redo\[rq] button can be pressed to reapply the last undone
change.
.PP
Press the \[lq]Revert All Changes\[rq] button to go back to the
original step order.
.SS Save the changes
.PP
Once the Workflow steps have been defined and order, changes are
permanently saved after pressing the \[lq]Create\[rq] button if new
or the \[lq]Update\[rq] button if the Job is being modified.
.SS Summary
.PP
At this point you should understand what a Job workflow is, the
kinds of steps they can contain and how to define a workflow.
.PP
Next, we'll cover more about RunDeck's Job Option features.
.PP
% RUNDECK(1) RunDeck User Manuals | Version 1.0 % Alex Honor %
November 20, 2010
.SH Job Options
.PP
Any command or script can be wrapped as a Job.
Creating a Job for every use case would proliferate a large number
of Jobs differing only by how the Job provides data to the scripts
they call.
These differences are often environment or application version
related.
Other times only the person running the Job can provide the needed
information to run the Job correctly.
.PP
Making your scripts and commands data driven, means they can become
more generic and therefore, resuable in different contexts.
Rather than maintain variations of the same basic process, letting
Jobs be driven by externally provided data leads to better
abstraction and encapsulation of your process.
.PP
RunDeck Jobs can be configured to prompt a user for input by
defining one or more named \f[I]options\f[].
An \f[I]option\f[] is a named parameter that can be required or
optional and include a range of choices that will be presented to
the user when the Job is run.
.PP
Users can supply options by typing in a value or selecting from a
menu of choices.
A validation pattern will ensure input complies to the option
requirement.
Once chosen, the value chosen for the option is accessible to the
commands called by the Job.
.PP
When option choices are restricted to a standard set, they can be
defined statically in the Job definition.
When option choices must be dynamic, the Job can be defined to use
a URL to retrieve option data from an external source.
Enabling Jobs to access external sources via URL opens the door to
integrating RunDeck with other tools and incorporating their data
into Job workflows.
.SS Prompting the user
.PP
The obvious effect from defining Job options is their appearance to
the user running the Job.
Users will be presented a page called
\[lq]Choose Execution Options\&...\[rq] where input and menu
choices must be configured.
.PP
Command line users executing Jobs via the run shell tool also will
specify options as an argument string.
.PP
It is worth spending a moment to consider how options become part
of the user interface to Jobs and give some thought to this next
level of procedure formalization.
.IP \[bu] 2
Naming and description convention: Visualize how the user will read
the option name and judge its purpose from the description you
supply.
.IP \[bu] 2
Required options: Making an option required means the Job will fail
if a user leaves it out.
.IP \[bu] 2
Input restrictions and validation: If you need to make the option
value be somewhat open ended consider how you can create safeguards
to control their choice.
.SS Options editor
.PP
Options can be created for any stored Job.
The Job edit page contains an area displaying a summary to existing
options and a link to add new ones or edit existing ones.
.PP
The option summary shows each option and its default value if it
defines them.
.PP
Clicking the \[lq]edit\[rq] link opens up the options editor.
.PP
The options editor displays an expanded summary for each defined
option.
Each option is listed with its usage summary, description, values
list and any restrictions.
Pressing the \[lq]Add an option\[rq] link will open a form to
define a new parameter.
Pressing the \[lq]Close\[rq] link will collapse the options editor
and return back to the summary view.
.PP
Moving the mouse over any row in the options editor reveals links
to delete or edit the highlighted option.
Pressing the remove icon will display a prompt confirming you want
to delete that option from the Job.
Clicking the \[lq]edit\[rq] link opens a new form that lets you
modify all aspects of that option.
.PP
Options can also be defined as part of an XML job definition and
later loaded to the RunDeck server.
See \[lq]job-v10(1)\[rq] and \[lq]rd-jobs(1)\[rq] manual pages if
you prefer using an XML Job definition.
.SS Defining an option
.PP
New options can be defined by pressing the \[lq]Add an option\[rq]
link while existing ones can be changed by pressing their
\[lq]edit\[rq] link.
.PP
The option definition form is organized into several areas:
.TP
.B Identification
Here you provide the option's name and description.
The name becomes part of acceptable arguments to the Job while the
description will be provided as help text to users running the Job.
.RS
.RE
.TP
.B Allowed values
This can contain a static list of values or a URL to a server
providing option data.
Values can be specified as a comma separated list as seen above but
can also be requested from an external source using a
\[lq]remote URL\[rq] See below (#remote-option-values).
.RS
.RE
.TP
.B Restrictions
Defines criteria on which input to accept or present.
Option choices can be controlled using the
\[lq]Enforced from values\[rq] restriction.
When set \[lq]true\[rq], RunDeck will only present a popup menu.
If set \[lq]false\[rq], a text field will also be presented.
Enter a regular expression in the
\[lq]Match Regular Expression\[rq] field the Job will evaluate when
run.
.RS
.RE
.TP
.B Requirement
Indicates if the Job can only run if a choice is provided for that
Option.
Choosing \[lq]No\[rq] states the option is not required Choose
\[lq]Yes\[rq] to state the option is required.
.RS
.RE
.PP
Once satisfied with the option definition, press the \[lq]Save\[rq]
button to add it to the Job definition.
Pressing the \[lq]Cancel\[rq] button will dismiss the changes and
close the form.
.SS Remote option values
.PP
If the \[lq]valuesUrl\[rq] is specified for an Option, then the
list of allowed values is retrieved from this URL.
File URL schemes are also acceptable (e.g,
file:///path/to/job/options/optA.json).
.PP
The accepted JSON data format is described below.
.SS JSON format
.PP
The format of the response is expected to be JSON data.
Two styles of return data are supported: list and object
.PP
\f[I]Examples\f[]
.PP
List:
.IP
.nf
\f[C]
["x\ value\ for\ test","y\ value\ for\ test"]
\f[]
.fi
.PP
This will populate the select menu with the given values.
.PP
Object:
.IP
.nf
\f[C]
{"X\ Label":"x\ value","Y\ Label":"y\ value",\ "A\ Label":"a\ value"}
\f[]
.fi
.PP
This will show only the labels, but the corresponding value will be
used in the option.
.SS Variable expansion in remote URLs
.PP
The URL used in the \[lq]valuesUrl\[rq] can embed variables which
will be filled with certain context items when making the remote
request.
This helps make the URLs more generic and contextual to the Job.
.PP
Two types of expansions are available, Job context, and Option
context.
.PP
To include job information in the URL, specify a variable of the
form ${job.\f[I]property\f[]}.
.PP
Properties available for Job context:
.IP \[bu] 2
name: Name of the Job
.IP \[bu] 2
group: Group of the Job
.IP \[bu] 2
description: Job description
.IP \[bu] 2
project: Project name
.IP \[bu] 2
argString: Default argument string for a job
.PP
To include Option information in the URL, specify a variable of the
form ${option.\f[I]property\f[]}:
.PP
Properties available for Option context:
.IP \[bu] 2
name: Name of the current option
.PP
\f[I]Examples\f[]
.IP
.nf
\f[C]
valuesUrl="http://server.com/test?name=${option.name}"
\f[]
.fi
.PP
Passes the option name as the \[lq]name\[rq] query parameter to the
URL.
.IP
.nf
\f[C]
valuesUrl="http://server.com/test?jobname=${job.name}&jobgroup=${job.group}"
\f[]
.fi
.PP
Passes the job name and group as query parameters.
.SS Remote request failures
.PP
If the request for the remote option values fails, then the GUI
form will display a warning message:
.RS
.PP
failed loading remote option values
.RE
.PP
In this case, the option will be allowed to use a textfield to set
the value.
.SS Script usage
.PP
Option values can be passed to scripts as an argument or referenced
inside the script via a named token.
Option values can be accessed in one of several ways:
.TP
.B Value passed as an environment variable:
Bash: $RD_OPTION_\f[I]NAME\f[] [1]
.RS
.RE
.TP
.B Value passed as an argument to a script:
Commandline Arguments: ${option.\f[I]name\f[]}
.RS
.RE
.TP
.B Value referenced as a replacement token inside the script:
Script Content: \@option.\f[I]vip\f[]\@
.RS
.RE
.PP
A single example helps illustrate these methods.
Imagine a trivial script is wrapped in a Job named \[lq]hello\[rq]
and has an option named \[lq]message\[rq].
The \[lq]hello\[rq] Job option signature would be
\[lq]-message <>\[rq].
Here's the content of this simple script.
.IP
.nf
\f[C]
\ \ \ \ #!/bin/sh\ \ \ \ 
\ \ \ \ echo\ envvar=$RD_OPTION_MESSAGE\ ;#\ read\ from\ environment
\ \ \ \ echo\ args=$1\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ;#\ comes\ from\ argument\ vector
\ \ \ \ echo\ message=\@option.message\@\ \ ;#\ replacement\ token
\f[]
.fi
.PP
When the user runs the \[lq]hello\[rq] job they will be prompted
for the \[lq]message\[rq] value.
Let's assume they type the word \[lq]hello\[rq] in response.
The output of the Job will be:
.IP
.nf
\f[C]
envar=hello
args=hello\ \ \ \ 
message=hello\ \ \ \ 
\f[]
.fi
.PP
It's important to know what happens if the option isn't set.
This can happen if you define an option that is not required and do
not give it a default value.
.PP
Let's imagine the Job was run without a message option supplied,
the output would look like this:
.IP
.nf
\f[C]
envar=
args=
message=\@option.message\@
\f[]
.fi
.PP
Here are some tips to deal with this possibility:
.TP
.B Environment variable:
As a precaution you might test existence for the variable and
perhaps set a default value.
To test its existence you might use:
.RS
.IP
.nf
\f[C]
\ test\ -s\ \ $RD_OPTION_NAME
\f[]
.fi
.PP
You might also use a Bash feature that tests and defaults it to a
value:
.IP
.nf
\f[C]
\ ${RD_OPTION_NAME:=mydefault}\ 
\f[]
.fi
.RE
.TP
.B Replacement token
If the option is unset the token will be left alone inside the
script.
You might write your script a bit more defensively and change the
implementation like so:
.RS
.RE
.IP
.nf
\f[C]
\ \ \ \ \ \ \ \ message=\@option.message\@
\ \ \ \ \ \ \ \ if\ [\ "$message"\ ==\ "\@option.message\@"\ ]\ ;\ then
\ \ \ \ \ \ \ \ \ \ \ message=mydefault
\ \ \ \ \ \ \ \ fi\ 
\f[]
.fi
.SS Calling a Job with options
.PP
Jobs can be invoked from the command line using the run shell tool
or as a step in another Job's workflow.
.PP
Using the run command pass them after the double hyphen:
.IP
.nf
\f[C]
run\ -j\ jobId\ --\ -paramA\ valA\ -paramB\ valB
\f[]
.fi
.PP
Inside an XML definition, insert them as an arg element:
.IP
.nf
\f[C]
<command>
\ \ \ \ <jobref\ group="test"\ name="other\ tests">
\ \ \ \ \ \ \ \ <arg\ line="-paramA\ valA\ -paramB\ valB"/>
\ \ \ \ </jobref>
</command>
\f[]
.fi
.PP
Consult the \[lq]run(1)\[rq] and \[lq]job-v20(1)\[rq] manual pages
for additional information.
.SS Summary
.PP
After reading this chapter you should understand how to run Jobs
with options, as well as, add and edit them.
% RUNDECK(1) RunDeck User Manuals | Version 1.0 % Alex Honor %
November 20, 2010
.SH Authorization
.PP
!!!! TODO !!!!
.SS Summary
.PP
% RUNDECK(1) RunDeck User Manuals | Version 1.0 % Alex Honor %
November 20, 2010
.SH Examples
.SS Summary
.PP
% RUNDECK(1) RunDeck User Manuals | Version 1.0 % Alex Honor %
November 20, 2010
.SH Coordinatation
.SS Execution strategies revisited
.SS Step vs Node oriented
.SS Topology structures: Tiers and Slices
.SS Coordination models
.PP
and job refs
.PP
jobs manage different tiers
.SS Sync points
.PP
Coordinate with sync points to understand when to continue or not
.SS Summary
.PP
% RUNDECK(1) RunDeck User Manuals | Version 1.0 % Alex Honor %
November 20, 2010
.SH Administration
.SS SSL
.SS LDAP
.SS Backup and recovery
.SS High availability
.SS Configuration
.PP
rdeck.base * linux: /etc/rundeck/client * launcher: $RDECK_BASE/etc
.PP
for server linux: /etc/rundeck/server (like jetty.home) laucher:
$RDECK_BASE/server
.SS Logs
.PP
linux: /var/log/rundeck launcher: $RDECK_BASE/var/logs
.SS Summary
.SH NOTES

.SS [1]
.PP
To pass environment variables through remote command dispatches, it
is required to properly configure the SSH server on the remote end.
See the AcceptEnv directive in the \[lq]sshd_config(5)\[rq] manual
page for instructions.
Use a wild card pattern to permit RD_ prefixed variables to provide
open access to RunDeck generated environment variables.
.SH AUTHORS
Alex Honor.
